~require-os require-dict require-io require-parser require-time require-math

:\ ^key 10 = `\ ,if-not* ,;
~\ One line comment

:( ^key ~key ) [,] ^= `( ,if-not* ,;
~( multilines comment )

~( boolean constant )
:true   ^1 ,;
:false  ^0 ,;

:on  ^1 swap c! ,;
:off ^0 swap c! ,;

:hex ^16 base c! ,;
:dec ^10 base c! ,;
:bin ^2 base c! ,;
:base? ^base c@ dup dec . base c! ,;

:% ^echo off ,;

~( helper words )
:2dup ^over over ,;
:2drop ^drop drop ,;

:1+ ^1 ,+ ;
:1- ^1 ,- ;

:+! ^dup @ rot + swap ! ,;
:1+! ^dup @ 1+ swap ! ,;
:1-! ^dup @ 1- swap ! ,;
:cell+! ^dup @ cell + swap ! ,;

:;; ,R> drop ;
:;;; ,;; ;; ;

:cells ,cell * ;

:noname> ^here @ ,;

~( loop )
:times-loop ~( xt - ) ,dup  execute I-- I@ `times-loop ,if* ,;
:times ~( ent n - ) ,I>R I! ^code> times-loop drop ,R>I ,;
:ctimes ~( xt n - ) ,I>R I! ^times-loop drop ,R>I ,;
'times-loop ~entry/hide

~( rendering )
:cr ^10 emit ,;
:tab ^9 emit ,;
:space ^32 emit ,;
:spaces ^space 1- dup `spaces ,if* ^drop ,;

~( dump word )
:emit. ^ drop 46 emit ,;
:v-emit ~( c - ) ^
  dup  32 < `emit. ,if; ^
  dup 128 < `emit. ,if-not; ^
  emit ,;

:dumpc ^swap dup c@ dup v-emit space . tab  1+ swap ,;
:dumpl ^dumpc 1- dup `dumpl ,if* ^drop ,;
:dumpb ^swap  12 dumpl  swap cr 1- dup `dumpb ,if* ,;
:dump ~( a - ) ^10 dumpb drop ,;
'dumpc ~entry/hide  'dumpl ~entry/hide  'dumpb ~entry/hide


:alloc ~( n - a ) ^here @ swap over + here ! ,;

:>! ^cell alloc ! ,;
:>c! ^1 alloc ! ,;

:data-heap-size ^50000 ,;
~data-heap-size c-alloc :dataheap ~[,] ,;
~cell alloc :dhere ~[,] ,;
~dataheap dhere !

:dalloc ~( n - a ) ^dhere @ swap over + dhere ! ,;

~\ patch the 'bye' entry to free the heap before calling the original 'bye'
~noname> ^dataheap c-free 'bye ~code> [,] ^execute ,;  'bye ~c>is

:>d! ^cell dalloc ! ,;
:>dc! ^1 dalloc ! ,;

:? ^@ . ,;
:variable ^cell dalloc dup [,] ! ,;
:variables ^cells dalloc [,] ,;
:constant ^[,] ,;

:[] ,cells + ;

~( create null-terminated string )
:"marker ~0 variable ,;
:"forget ^"marker @ dhere ! ,;


:"init ^dhere @  dup "marker !  cell + ,;
:."key ^dup  echo c@ `emit `drop ,if-else ,;
:"loop ^dup key ."key dup ~key " [,] ^= `nop ,if; ^swap c! 1 + "loop ,;
:"done ^drop drop dhere @ - dup ^1 + dalloc swap cell - over ! ,;
:" ^"init "loop "done ,;
:c" ^" [,] ,;

~( print string )
:."init ^dup dup @ + cell + swap cell + ,;
:."loop ^over over = `nop ,if; ^dup c@ emit 1 + ."loop ,;
:pr
:." ^."init ."loop 2drop ,;
:prn ^pr cr ,;
:npr ^cr pr ,;
:nprn ^cr pr cr ,;

:droom
   ~c" Data: " ^pr dhere @  dataheap - dup . ~c" / " ^pr data-heap-size .
   100 * data-heap-size / . ~c" %" ^prn ,;
:dmarker ^dhere @  [,] ,;
:dforget ^dhere ! ,;

~( system )
:cmd ^cell + system ,;

~( marker/forget )
:marker ^latest @   here @ 6 cells +   [,] [,] ,;
:forget ^latest !   here ! ,;

~( files )
:aload ~( filename - buf ) ^
   dup file-size cell + c-alloc
   dup rot load ,;

~( mem move )
:-cmove-done?; ^1- dup `nop ,if; ^2drop drop ,;; ,;
:cmove-advance ^ 1+ ,;
:cmove-loop ^
   ,>R  ^swap dup c@ ,>R ^cmove-advance
   swap dup ,R> ^swap c! cmove-advance
   ,R> ^-cmove-done?; cmove-loop
,;
:cmove ~( src dst n - ) ^
   `1+ `cmove-advance ^is
   cmove-loop ,;

:cmove> ~( src dst n - ) ^
  1- ,>R R@ ^+ swap ,R@ ^+ swap ,R> ^1+
  `1- `cmove-advance ^is
  cmove-loop ,;

~( math )
:sign/0 ^drop 0 ,;   :sign/1 ^1 ,;   :sign/-1 ^-1 ,;
:sign ^dup `sign/0 ,if-not; ^0 < `sign/-1 `sign/1 ,if-else ,;
'sign/0 ~entry/hide 'sign/1 ~entry/hide 'sign/-1 ~entry/hide


~( eval )
:ptr ~0 variable ,;
:count ~0 variable ,;
:loop ^ptr @ c@ parse  ptr 1+!  count 1-!  count @ `loop ,if* ,;
:eval ~( string - ) ^clear-tib  dup cell + ptr !  @ count !  loop  32 parse ,;
'ptr ~entry/hide  'count ~entry/hide  'loop ~entry/hide

~( time )
:time/start ^utime [,] ,;
:time/end ^utime swap - 1000 / . ~c" ms elapsed" ^prn ,;

~( hash )
:hash" ^" hash ,;
:.hash" ^base c@  hash" hex cr . cr base c! ,;

~( include and require )
:include" ^" included ,;
